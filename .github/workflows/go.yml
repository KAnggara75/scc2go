name: Go CI/CD with Semantic Versioning

on:
  push:
    branches: [main, master]
  #   paths:
  #     - "**/*.go"
  #     - "go.mod"
  #     - "go.sum"
  # pull_request:
  #   paths:
  #     - "**/*.go"
  #     - "go.mod"
  #     - "go.sum"

env:
  GOTOOLCHAIN: local

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        go-version: ["1.24", "1.25"]
    name: Build ${{ matrix.go-version == '1.25' && '(latest)' || '(old)' }}

    steps:
      - uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ matrix.go-version }}

      - name: Build
        run: go build -v ./...

      - name: Test with Coverage
        run: go test -v -race -coverprofile=coverage.out -covermode=atomic ./...

      - name: Upload coverage reports to Codecov
        if: matrix.go-version == '1.25'
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage.out
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Install goimports
        run: |
          go install golang.org/x/tools/cmd/goimports@latest
          export PATH="$HOME/go/bin:$PATH"

      - name: Run pre-commit
        uses: pre-commit/action@v3.0.1

  semantic-release:
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup SSH signing key (with passphrase)
        shell: bash
        env:
          RELEASE_BOT_SSH_KEY: ${{ secrets.RELEASE_BOT_SSH_KEY }}
          RELEASE_BOT_SSH_PASSPHRASE: ${{ secrets.RELEASE_BOT_SSH_PASSPHRASE }}
        run: |
          set -euo pipefail

          # Setup SSH directory and key
          mkdir -p ~/.ssh
          echo "$RELEASE_BOT_SSH_KEY" > ~/.ssh/id_ed25519_encrypted
          chmod 600 ~/.ssh/id_ed25519_encrypted
          ssh-keyscan github.com >> ~/.ssh/known_hosts
          chmod 644 ~/.ssh/known_hosts

          # Remove passphrase from key for this workflow (Git SSH signing doesn't work well with passphrases)
          if [ -n "$RELEASE_BOT_SSH_PASSPHRASE" ]; then
            # Use ssh-keygen to remove the passphrase
            ssh-keygen -p -P "$RELEASE_BOT_SSH_PASSPHRASE" -N "" -f ~/.ssh/id_ed25519_encrypted
          fi

          # Move to final location
          mv ~/.ssh/id_ed25519_encrypted ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519

          # Start SSH agent and add key (now without passphrase)
          eval "$(ssh-agent -s)"
          ssh-add ~/.ssh/id_ed25519

          # Configure git for SSH signing
          git config --global user.name "pakaiwa-release-bot"
          git config --global user.email "release@pakaiwa.dev"
          git config --global gpg.format ssh

          # Create public key for signing
          ssh-keygen -y -f ~/.ssh/id_ed25519 > ~/.ssh/id_ed25519.pub
          git config --global user.signingkey ~/.ssh/id_ed25519.pub
          git config --global tag.gpgsign true

          # Configure git to use SSH instead of HTTPS
          git config --global url."git@github.com:".insteadOf "https://github.com/"

          # Export SSH_AUTH_SOCK for subsequent steps
          echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
          echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV

      - name: Get Latest Tag
        id: get_latest_tag
        run: |
          git fetch --tags --quiet
          latest_tag=$(git tag -l "v*.*.*" | sort -V | tail -n1)
          if [ -z "$latest_tag" ]; then
            latest_tag="v0.0.0"
          fi
          echo "latest_tag=$latest_tag" >> "$GITHUB_OUTPUT"
          echo "Latest tag: $latest_tag"

      - name: Determine Version Bump
        id: version_bump
        run: |
          latest_tag="${{ steps.get_latest_tag.outputs.latest_tag }}"

          # Parse current version
          current_version=${latest_tag#v}
          IFS='.' read -r major minor patch <<< "$current_version"

          # Get commit messages since last tag
          if [ "$latest_tag" = "v0.0.0" ]; then
            commits=$(git log --pretty=format:"%s" HEAD)
          else
            commits=$(git log --pretty=format:"%s" ${latest_tag}..HEAD)
          fi

          echo "Analyzing commits:"
          echo "$commits"

          # Determine bump type based on conventional commits
          bump_type="none"

          # Check for BREAKING CHANGE (major bump)
          if echo "$commits" | grep -qiE "BREAKING CHANGE:|^[a-z]+(\(.+\))?!:"; then
            bump_type="major"
            major=$((major + 1))
            minor=0
            patch=0
          # Check for feat: (minor bump)
          elif echo "$commits" | grep -qiE "^feat(\(.+\))?:"; then
            bump_type="minor"
            minor=$((minor + 1))
            patch=0
          # Check for fix:, perf:, refactor: (patch bump)
          elif echo "$commits" | grep -qiE "^(fix|perf|refactor)(\(.+\))?:"; then
            bump_type="patch"
            patch=$((patch + 1))
          # Default to patch for any other commits
          elif [ -n "$commits" ]; then
            bump_type="patch"
            patch=$((patch + 1))
          fi

          new_version="v${major}.${minor}.${patch}"

          echo "bump_type=$bump_type" >> "$GITHUB_OUTPUT"
          echo "new_version=$new_version" >> "$GITHUB_OUTPUT"
          echo "Version bump: $latest_tag -> $new_version (type: $bump_type)"

      - name: Check if Tag Exists
        id: check_tag
        run: |
          new_version="${{ steps.version_bump.outputs.new_version }}"
          if git rev-parse -q --verify "refs/tags/$new_version" >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "Tag $new_version already exists"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "Tag $new_version does not exist"
          fi

      - name: Generate Changelog
        id: changelog
        if: steps.check_tag.outputs.exists == 'false' && steps.version_bump.outputs.bump_type != 'none'
        run: |
          latest_tag="${{ steps.get_latest_tag.outputs.latest_tag }}"
          new_version="${{ steps.version_bump.outputs.new_version }}"

          if [ "$latest_tag" = "v0.0.0" ]; then
            commits=$(git log --pretty=format:"- %s (%h)" HEAD)
          else
            commits=$(git log --pretty=format:"- %s (%h)" ${latest_tag}..HEAD)
          fi

          changelog="## $new_version ### Changes $commits"
          echo "changelog<<EOF" >> "$GITHUB_OUTPUT"
          echo "$changelog" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Create and Push Tag
        if: steps.check_tag.outputs.exists == 'false' && steps.version_bump.outputs.bump_type != 'none'
        run: |
          new_version="${{ steps.version_bump.outputs.new_version }}"
          changelog="${{ steps.changelog.outputs.changelog }}"

          # Use the same credentials as SSH setup
          git config user.name "pakaiwa-release-bot"
          git config user.email "release@pakaiwa.my.id"

          # Ensure we're using SSH remote
          git remote set-url origin git@github.com:KAnggara75/scc2go.git

          # Create signed tag
          git tag -s "$new_version" -m "$changelog"

          # Push tag using SSH
          git push origin "$new_version"

          echo "âœ… Created and pushed signed tag: $new_version"

      - name: Create GitHub Release
        if: steps.check_tag.outputs.exists == 'false' && steps.version_bump.outputs.bump_type != 'none'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version_bump.outputs.new_version }}
          release_name: Release ${{ steps.version_bump.outputs.new_version }}
          body: ${{ steps.changelog.outputs.changelog }}
          draft: false
          prerelease: false
