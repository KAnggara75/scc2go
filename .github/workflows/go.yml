name: Go CI/CD with Semantic Versioning

on:
  push:
    branches: [main, master]
    paths:
      - "**/*.go"
      - "go.mod"
      - "go.sum"
  pull_request:
    paths:
      - "**/*.go"
      - "go.mod"
      - "go.sum"

env:
  GOTOOLCHAIN: local

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    strategy:
      fail-fast: false
      matrix:
        go-version: ["1.24", "1.25"]
    name: Build ${{ matrix.go-version == '1.25' && '(latest)' || '(old)' }}

    steps:
      - uses: actions/checkout@v6

      - name: Set up Go
        uses: actions/setup-go@v6
        with:
          go-version: ${{ matrix.go-version }}

      - name: Build
        run: go build -v ./...

      - name: Test with Coverage
        run: go test -v -race -coverprofile=coverage.out -covermode=atomic ./...

      - name: Upload coverage reports to Codecov
        if: matrix.go-version == '1.25'
        uses: codecov/codecov-action@v5
        with:
          files: ./coverage.out
          fail_ci_if_error: false
          token: ${{ secrets.CODECOV_TOKEN }}

      - name: Install goimports
        run: |
          go install golang.org/x/tools/cmd/goimports@latest
          export PATH="$HOME/go/bin:$PATH"

      - name: Run pre-commit
        uses: pre-commit/action@v3.0.1

  semantic-release:
    runs-on: ubuntu-latest
    needs: build
    if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master')
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup SSH signing key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.RELEASE_BOT_SSH_KEY }}" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          ssh-keyscan github.com >> ~/.ssh/known_hosts

          git config --global user.name "pakaiwa-release-bot"
          git config --global user.email "release@pakaiwa.dev"
          git config --global gpg.format ssh
          git config --global user.signingkey ~/.ssh/id_ed25519
          git config --global commit.gpgsign false
          git config --global tag.gpgsign true

      - name: Get Latest Tag
        id: get_latest_tag
        run: |
          git fetch --tags --quiet
          latest_tag=$(git tag -l "v*.*.*" | sort -V | tail -n1)
          if [ -z "$latest_tag" ]; then
            latest_tag="v0.0.0"
          fi
          echo "latest_tag=$latest_tag" >> "$GITHUB_OUTPUT"
          echo "Latest tag: $latest_tag"

      - name: Determine Version Bump
        id: version_bump
        run: |
          latest_tag="${{ steps.get_latest_tag.outputs.latest_tag }}"

          # Parse current version
          current_version=${latest_tag#v}
          IFS='.' read -r major minor patch <<< "$current_version"

          # Get commit messages since last tag
          if [ "$latest_tag" = "v0.0.0" ]; then
            commits=$(git log --pretty=format:"%s" HEAD)
          else
            commits=$(git log --pretty=format:"%s" ${latest_tag}..HEAD)
          fi

          echo "Analyzing commits:"
          echo "$commits"

          # Determine bump type based on conventional commits
          bump_type="none"

          # Check for BREAKING CHANGE (major bump)
          if echo "$commits" | grep -qiE "BREAKING CHANGE:|^[a-z]+(\(.+\))?!:"; then
            bump_type="major"
            major=$((major + 1))
            minor=0
            patch=0
          # Check for feat: (minor bump)
          elif echo "$commits" | grep -qiE "^feat(\(.+\))?:"; then
            bump_type="minor"
            minor=$((minor + 1))
            patch=0
          # Check for fix:, perf:, refactor: (patch bump)
          elif echo "$commits" | grep -qiE "^(fix|perf|refactor)(\(.+\))?:"; then
            bump_type="patch"
            patch=$((patch + 1))
          # Default to patch for any other commits
          elif [ -n "$commits" ]; then
            bump_type="patch"
            patch=$((patch + 1))
          fi

          new_version="v${major}.${minor}.${patch}"

          echo "bump_type=$bump_type" >> "$GITHUB_OUTPUT"
          echo "new_version=$new_version" >> "$GITHUB_OUTPUT"
          echo "Version bump: $latest_tag -> $new_version (type: $bump_type)"

      - name: Check if Tag Exists
        id: check_tag
        run: |
          new_version="${{ steps.version_bump.outputs.new_version }}"
          if git rev-parse -q --verify "refs/tags/$new_version" >/dev/null 2>&1; then
            echo "exists=true" >> "$GITHUB_OUTPUT"
            echo "Tag $new_version already exists"
          else
            echo "exists=false" >> "$GITHUB_OUTPUT"
            echo "Tag $new_version does not exist"
          fi

      - name: Generate Changelog
        id: changelog
        if: steps.check_tag.outputs.exists == 'false' && steps.version_bump.outputs.bump_type != 'none'
        run: |
          latest_tag="${{ steps.get_latest_tag.outputs.latest_tag }}"
          new_version="${{ steps.version_bump.outputs.new_version }}"

          if [ "$latest_tag" = "v0.0.0" ]; then
            commits=$(git log --pretty=format:"- %s (%h)" HEAD)
          else
            commits=$(git log --pretty=format:"- %s (%h)" ${latest_tag}..HEAD)
          fi

          changelog="## $new_version ### Changes $commits"
          echo "changelog<<EOF" >> "$GITHUB_OUTPUT"
          echo "$changelog" >> "$GITHUB_OUTPUT"
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Create and Push Tag
        if: steps.check_tag.outputs.exists == 'false' && steps.version_bump.outputs.bump_type != 'none'
        run: |
          new_version="${{ steps.version_bump.outputs.new_version }}"
          changelog="${{ steps.changelog.outputs.changelog }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git tag -s "$new_version" -m "$changelog"
          git push origin "$new_version"

          echo "âœ… Created and pushed tag: $new_version"

      - name: Create GitHub Release
        if: steps.check_tag.outputs.exists == 'false' && steps.version_bump.outputs.bump_type != 'none'
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.version_bump.outputs.new_version }}
          release_name: Release ${{ steps.version_bump.outputs.new_version }}
          body: ${{ steps.changelog.outputs.changelog }}
          draft: false
          prerelease: false
